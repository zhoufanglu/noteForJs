<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>

</body>
<script>
    //es5 寄生组合继承
    /**
     * @param name
     * @param age
     * @constructor
     */
    function Person_A(name, age) {
        this.name = name
        this.age = age
        this.say = function () {
            console.log(`我叫${name},${age}岁了`)
        }
    }
    let personA = new Person_A('lfz', 26)
    console.log(22, personA)

    /**
     * @param name
     * @param age
     * @param sex
     * @constructor
     */
    function Person_B(name, age, sex) {
        Person_A.call(this, name, age)
        this.sex = sex
    }
    Person_B.prototype = Object.create(Person_A.prototype)
    let personB = new Person_B('sxy', 25, '女')
    //console.log(33,Person_B.prototype)
    personB.say()
    /**总结**
     * 1、先要让Person_A的this指向Person_B，还要传参
     * 2、然后通过prototype来进行对象构建
     */
    console.log('-------------------------------')
    
    //es6继承
    class Dog_A{
        constructor(age, name) {
            this.age = age
            this.name = name
        }
        say(){
            console.log(`我是一条叫${this.name}的狗，今年${this.age}岁了`)
        }
    }
   /* const dog_A = new Dog_A({name:'lfz',age: 26})
    dog_A.say()*/

    class Dog_B extends Dog_A{
        constructor(name) {
            console.log(62, name)
            super(12,name)
        }
    }
    const dog_B = new Dog_B('xxx')
    dog_B.say()
    /**
     * es6继承总结
     * 在最外面 class层使用extends 来继承
     * super来传参
     */

</script>
</html>