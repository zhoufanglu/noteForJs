<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
</head>
<body>

<script>
  /*
  字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段
  ，同一个字母只会出现在其中的一个片段。
  返回一个表示每个字符串片段的长度的列表。
  ---
  输入：S = "ababcbacadefegdehijhklij"
  输出：[9,7,8]
  解释：
  划分结果为 "ababcbaca", "defegde", "hijhklij"。
  每个字母最多出现在一个片段中。
  像 "ababcbacadefegde", "hijhklij" 的划分是错误的，因为划分的片段数较少。
*/
/*
/**
 * @param {string} S
 * @return {number[]}
 */
  const partitionLabels = function (S) {
    let str = S
    console.log(1, str)

    const maxPos = {};
    for (let i = 0; i < S.length; i++) { // 存放字母与它的最远位置
      maxPos[S[i]] = i;
    }
    console.log(35, maxPos)

    let startIndex = 0 //检索开始
    let endIndex = str.length-1 //检索最后的位置
    //找到检索到相同的索引
    findNoRepeatStr(str, startIndex, endIndex)
    
  }
  //partitionLabels('ababcbacadefegdehijhklij')
  partitionLabels('abaeafeg')

  function findNoRepeatStr(str, startIndex, endIndex, lastTimeIndex) {
    console.log(startIndex,'----',endIndex)
    let returnArr = []

    if(endIndex === 0){
      return  returnArr
    }

    if(str[startIndex] === str[endIndex]){
      let cutStr1 = str.substring(0, endIndex+1)
      let cutStr2 = str.substring(endIndex+1, str.length)
      console.log(46, cutStr1, cutStr2)
      //判断有无交集
      if(!checkTwoStringIsSame(cutStr1, cutStr2)){
        //如果没有交集， 把str1塞入数组
        returnArr.push(cutStr1)
        str = cutStr2
      }else{
        //如果有交集，索引往后移动重新检查
        endIndex = endIndex + 1
        console.log('往后检索+1', endIndex)
        //return findNoRepeatStr(str, startIndex, endIndex)
      }
    }
    else{
      return findNoRepeatStr(str, startIndex, --endIndex)
    }

    returnArr.push(str)
    console.log('-------')
    console.log(returnArr)
  }

  function checkTwoStringIsSame(str1, str2) {
    let flag = false
    for(let i=0;i<str1.length;i++){
      if(str2.indexOf(str1[i])!==-1){
        flag = true
        break
      }
    }
    return flag
  }

</script>
</body>
</html>